```json
{
  "keyPoints": [
    "A finite field is a finite commutative ring with 1 in which every nonzero element has a multiplicative inverse.",
    "Every finite field has size p^n (p prime), and for each p^n there exists (up to isomorphism) a unique field GF(p^n)."
  ],
  "definitions": [
    "Field: (F,+,·) where (F,+) is an abelian group, (F\\{0},·) is an abelian group, and · distributes over +.",
    "Characteristic: the least positive integer p such that p·1=0 (or 0 if none); for finite fields, char(F)=p is prime."
  ],
  "coreDerivations": [
    "Show char(F) is prime; then show finite field is a finite-dimensional vector space over its prime subfield GF(p), hence |F|=p^n."
  ],
  "labAPIs": [
    "mod_add(a,b,p)",
    "mod_mul(a,b,p)",
    "mod_inv(a,p)",
    "is_field_mod_p(p)"
  ],
  "edgeCases": [
    "p not prime ⇒ Z/pZ is not a field (zero divisors), inverses may not exist.",
    "Attempting inverse of 0 must raise/return error."
  ],
  "attackScenario": "Exploit a developer assuming arithmetic mod a composite is a field, causing invalid inverses and broken cryptographic proofs."
}
```

## Formal Explanation

### Core objects and notation
- A **ring with 1**: set \(R\) with operations \(+\), \(\cdot\), additive identity \(0\), multiplicative identity \(1\), satisfying ring axioms; assume \(\cdot\) associative and distributive over \(+\).
- A **field** \(F\):
  - \((F,+)\) is an abelian group.
  - \((F\setminus\{0\},\cdot)\) is an abelian group (so every nonzero has an inverse).
  - Distributivity: \(a(b+c)=ab+ac\), \((a+b)c=ac+bc\).
- **Finite field**: a field with \(|F|<\infty\). Standard notation: \(\mathbb{F}_q\) or \(\mathrm{GF}(q)\) where \(q=|F|\).
- **Prime subfield**: the smallest subfield of \(F\), generated by \(1\): \(\{0,1,1+1,\dots\}\).
- **Characteristic** \(\mathrm{char}(F)\):
  - \(\mathrm{char}(F)=p\) if \(p\) is the least positive integer with \(p\cdot 1=0\).
  - Otherwise \(\mathrm{char}(F)=0\).
  - For finite fields, \(\mathrm{char}(F)\) is a prime.

### Sanity facts (used constantly)
- In a field, there are **no zero divisors**: \(ab=0 \Rightarrow a=0\) or \(b=0\).
- \(\mathbb{Z}/p\mathbb{Z}\) is a field iff \(p\) is prime.

---

## Derivation

### Theorem 1: \(\mathrm{char}(F)\) is prime for any field \(F\)
- Assume \(\mathrm{char}(F)=n>0\). Then \(n\cdot 1=0\) and \(n\) is minimal.
- Suppose \(n\) is composite: \(n=ab\) with \(1<a,b<n\).
- Compute in \(F\):
  - \((a\cdot 1)(b\cdot 1) = (ab)\cdot 1 = n\cdot 1 = 0\).
- Since \(F\) has no zero divisors, either \(a\cdot 1=0\) or \(b\cdot 1=0\).
- But \(a<n\) and \(b<n\), contradicting minimality of \(n\).
- Therefore \(n\) must be prime. Write \(n=p\).

### Theorem 2: If \(F\) is finite, then \(|F|=p^m\) for some prime \(p\) and integer \(m\ge 1\)
- Let \(p=\mathrm{char}(F)\) (prime by Theorem 1).
- Define a map \(\phi:\mathbb{Z}\to F\) by \(\phi(k)=k\cdot 1\).
  - \(\phi\) is a ring homomorphism (check: \(\phi(k+\ell)=\phi(k)+\phi(\ell)\), \(\phi(k\ell)=\phi(k)\phi(\ell)\)).
- Kernel: \(\ker\phi = p\mathbb{Z}\) because \(p\) is the least positive integer with \(p\cdot 1=0\).
- By the first isomorphism theorem:
  - \(\mathbb{Z}/p\mathbb{Z} \cong \mathrm{im}(\phi)\).
- Thus \(F\) contains a subfield isomorphic to \(\mathbb{F}_p\) (the **prime subfield**).
- View \(F\) as a vector space over \(\mathbb{F}_p\):
  - Scalar multiplication: \((\bar{k})\cdot x := (k\cdot 1)x\).
- Since \(F\) is finite, this vector space has finite dimension \(m\).
- A vector space of dimension \(m\) over \(\mathbb{F}_p\) has exactly \(p^m\) elements.
- Hence \(|F|=p^m\).

---

## Implementation Lab

### Goal
Implement arithmetic in \(\mathbb{F}_p\) (integers mod prime \(p\)) with validation and inverses.

### Reference APIs
- `mod_add(a,b,p)`: return \((a+b)\bmod p\)
- `mod_mul(a,b,p)`: return \((ab)\bmod p\)
- `mod_inv(a,p)`: return \(a^{-1}\bmod p\) if it exists
- `is_field_mod_p(p)`: return True iff \(\mathbb{Z}/p\mathbb{Z}\) is a field (i.e., \(p\) prime)

### Python reference implementation
```python
def is_prime(p: int) -> bool:
    if p <= 1:
        return False
    if p <= 3:
        return True
    if p % 2 == 0:
        return False
    d = 3
    while d * d <= p:
        if p % d == 0:
            return False
        d += 2
    return True

def is_field_mod_p(p: int) -> bool:
    return is_prime(p)

def mod_add(a: int, b: int, p: int) -> int:
    if not is_prime(p):
        raise ValueError("Modulus p must be prime for a field.")
    return (a + b) % p

def mod_mul(a: int, b: int, p: int) -> int:
    if not is_prime(p):
        raise ValueError("Modulus p must be prime for a field.")
    return (a * b) % p

def egcd(a: int, b: int):
    # returns (g,x,y) with ax+by=g=gcd(a,b)
    x0, y0, x1, y1 = 1, 0, 0, 1
    while b != 0:
        q = a // b
        a, b = b, a - q * b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return a, x0, y0

def mod_inv(a: int, p: int) -> int:
    if not is_prime(p):
        raise ValueError("Modulus p must be prime for a field.")
    a %= p
    if a == 0:
        raise ZeroDivisionError("0 has no multiplicative inverse.")
    g, x, _ = egcd(a, p)
    # For prime p and a != 0, gcd(a,p)=1
    if g != 1:
        raise ValueError("Inverse does not exist (unexpected for prime p).")
    return x % p
```

### Edge-case checks (must pass)
- Composite modulus:
  - `is_field_mod_p(15) == False`
  - `mod_inv(2, 15)` must raise `ValueError`.
- Zero inverse:
  - `mod_inv(0, 7)` must raise `ZeroDivisionError`.
- Correctness spot-check:
  - For random `a != 0`: `mod_mul(a, mod_inv(a,p), p) == 1`.

### Computational exercises (3)
1. In \(\mathbb{F}_7\), compute:
   - \(3^{-1}\), \(5^{-1}\), and verify \(3\cdot 3^{-1}\equiv 1\), \(5\cdot 5^{-1}\equiv 1\pmod 7\).
2. Decide whether \(\mathbb{Z}/21\mathbb{Z}\) is a field. If not, exhibit a nonzero zero divisor pair \(a,b\) with \(ab\equiv 0\pmod{21}\).
3. Let \(F\) be a finite field with \(|F|=125\). Determine \(\mathrm{char}(F)\) and the vector space dimension \(m\) over its prime subfield.

(You should sanity-check each result: inverses exist iff modulus is prime and element nonzero; sizes must be prime powers.)

---

## Adversarial Thinking Challenge

### Scenario (1)
A protocol designer implements “field arithmetic” modulo \(n=2^{255}-19\) (prime) in one module, but later swaps \(n\) to a composite “for performance,” keeping the same inverse routine and security proof assumptions.

**Task**
- Identify the precise mathematical assumption that breaks.
- Give a concrete failure mode:
  - Find a composite \(n\) and a nonzero \(a\) such that `mod_inv(a,n)` does not exist (i.e., \(\gcd(a,n)\ne 1\)).
- Explain how this can invalidate cryptographic arguments (e.g., division steps in proofs, uniqueness of solutions, group order reasoning).

**Pitfalls to name**
- Confusing “ring” \(\mathbb{Z}/n\mathbb{Z}\) with “field.”
- Assuming cancellation: from \(ax=ay\) concluding \(x=y\) (fails with zero divisors).

---

## Mastery Requirements

### You pass (≥80%) if you can:
- **Definitions (O1)**: State field axioms, characteristic, prime subfield, and \(\mathbb{F}_p\) notation correctly.
- **Derivations (O2)**: Reproduce both proofs:
  - \(\mathrm{char}(F)\) is prime (via zero divisors + minimality).
  - \(|F|=p^m\) (via prime subfield + vector space counting).
- **Computation (O3)**: Correctly solve all 3 exercises with sanity checks.
- **Implementation (O4)**: Provide working `mod_inv` using EEA, with:
  - prime validation,
  - `a==0` handling,
  - correct normalization mod \(p\).
- **Adversarial (O5)**: Clearly articulate why composite moduli break “field” reasoning and give a concrete counterexample (zero divisor / non-invertible element).